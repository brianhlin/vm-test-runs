#!/usr/bin/python

import re
import os
import sys
import string
import time
import itertools
import yaml
import taglib
from taglib import Tag, SubTag


CSS_URI =  "http://vdt.cs.wisc.edu/tests/vmu.css"
m = re.search('run-((\d*)-\d*)', os.getcwd())
date = m.group(2)
timestamp = m.group(1)
url_base = "http://vdt.cs.wisc.edu/tests/" + timestamp + "/"
repo_filename = "results.html"
pkg_filename = "packages.html" 
homepage = url_base +  repo_filename
pkg_organized_homepage = url_base + pkg_filename

os_translation = {'centos_5_x86_64':{'dver':5, 'short':'CentOS'},
                  'centos_6_x86_64':{'dver':6, 'short':'CentOS'},
                  'rhel_5_x86_64':{'dver':5, 'short':'Red Hat'},
                  'rhel_6_x86_64':{'dver':6, 'short':'Red Hat'},
                  'sl_5_x86_64':{'dver':5, 'short':'Scientific'},
                  'sl_6_x86_64':{'dver':6, 'short':'Scientific'}}

def create_html_and_table():
    html = taglib.Html(page_title='OSG VMU Automated Test Results', css_link=CSS_URI)
    html.body.append_new_tag('h1').append('OSG VMU Automated Test Results')
    html.body.append_new_tag('h2').append(timestamp)
    table = html.body.append_new_tag('table', class_ = 'padded')

    return html, table

def sort_platforms_by_dver(platforms):
    global num_el5
    global num_el6

    organized_platforms = []
    num_el5 = 0
    for platform in platforms:
        if os_translation[platform]['dver'] == 5:
            organized_platforms.insert(num_el5, platform)
            num_el5 = num_el5 + 1
        else:
            organized_platforms.append(platform)

    num_el6 = len(platforms) - num_el5
    return organized_platforms

def concat_packages(packages):
    for idx, package in enumerate(packages):
        packages[idx] = string.join(package, ', ')

    return packages
    

def make_data_grid(runs, test_params, organization_scheme='repos'):
    num_rows = range(0,len(runs)/len(test_params['platform'])) 
    organized_runs = [[None] * len(test_params['platform']) for i in num_rows] # Create a 2D array to hold the runs
    for run in runs:
        # Find column value in the grid
        for idx, platform in enumerate(test_params['platform']):
            dver_regex = '[^\d]' + str(os_translation[platform]['dver']) + '\.'
            if (re.match(os_translation[platform]['short'], run['os_release']) and
                re.search(dver_regex, run['os_release'])):
                column = idx
                break
            
        # Find row value in the grid
        for idx, package in enumerate(test_params['packages']):
            if package == run['param_packages']:
                package_idx = idx
                break

        for idx, repo in enumerate(test_params['repository']):
            if repo == run['param_sources']:
                repo_idx = idx
                break

        if organization_scheme == 'packages':
            row = repo_idx + package_idx * len(test_params['repository'])
        else:
            row = package_idx + repo_idx  * len(test_params['packages'])

        organized_runs[row][column] = run
    return organized_runs

def create_table_headers(table, organization_scheme='repos'):
    if organization_scheme == 'packages':
        sort_link = homepage
        sort_link_text = 'Sort by Release &#9660;'
        first_column_text = 'Parent Package &#9660;'
        second_column_text = 'OSG Release/Upgrade'
    else:
        sort_link = pkg_organized_homepage
        sort_link_text = 'Sort by Package &#9660;'
        first_column_text = 'OSG Release/Upgrade &#9660;'
        second_column_text = 'Parent Package'

    header = table.append_new_tag("thead")
    row_1 = header.append_new_tag("tr")
    th = row_1.append_new_tag("th", rowspan="2", id = 'sort')
    th.append_new_tag('span', id = 'hide_text').append(first_column_text)
    th.append_new_tag('a', href=sort_link, id = 'sort_link').\
        append(sort_link_text) # mouseover text/link
    row_1.append_new_tag("th", rowspan="2").append(second_column_text)

    row_1.append_new_tag("th", colspan=num_el5).append("EL5")
    row_1.append_new_tag("th", colspan=num_el6).append("EL6")

    row_2 = header.append_new_tag("tr")
    for platform in test_params['platform']:
        row_2.append_new_tag("th").append(os_translation[platform]['short'])

    return table

def populate_table_data(table, data, organization_scheme='repos'):
    repo_translation = {'3.1; osg':'3.1 Release',
                        '3.1; osg-testing':'3.1 Testing',
                        '3.1; osg > osg-testing':'3.1 Release -> 3.1 Testing',
                        '3.2; osg':'3.2 Release',
                        '3.2; osg-testing':'3.2 Testing',
                        '3.2; osg > osg-testing':'3.2 Release -> 3.2 Testing',
                        '3.1; osg > 3.2/osg':'3.1 Release -> 3.2 Release',
                        '3.1; osg-testing > 3.2/osg-testing':'3.1 Testing -> 3.2 Testing'}
    
    pkg_translation = {'osg-tested-internal':'Everything',
                       'condor.x86_64, osg-ce-condor, rsv':'Condor',
                       'osg-gridftp, edg-mkgridmap, rsv':'GridFTP',
                       'osg-se-bestman, rsv':'BeStMan',
                       'osg-voms, rsv':'VOMS',
                       'osg-gums, rsv':'GUMS'}

    if organization_scheme == 'packages':
        outer_org = test_params['packages']
        inner_org = test_params['repository']
        outer_translation = pkg_translation
        inner_translation = repo_translation
    else:
        outer_org = test_params['repository']
        inner_org = test_params['packages']
        outer_translation = repo_translation
        inner_translation = pkg_translation

    tbody = table.append_new_tag('tbody')

    for row_tuple, inner in itertools.izip(enumerate(data), itertools.cycle(inner_org)):
        row_num = row_tuple[0]
        columns = row_tuple[1]
        rowspan_size = len(inner_org)
        if row_num % rowspan_size == 0:
            tbody.append_new_tag('tr').append_new_tag('td', class_ = 'divider')
            trow = tbody.append_new_tag('tr')
            outer = outer_org[row_num/rowspan_size]
            trow.append_new_tag('th', valign='top', rowspan=rowspan_size).append(outer_translation[outer])
        else:
            trow = tbody.append_new_tag('tr')
        trow.append_new_tag('th').append(inner_translation[inner])
        for cell in columns:
            trow.append(get_cell_contents(cell))

def get_cell_contents(run):
    run_dir = url_base + run['job_serial']

    # Generic info for each cell
    mouseover_text = 'Hostname: ' + run['host_name'] + '&#013;' + \
        'Host IP: ' + run['host_address'] + '&#013;' + \
        'Job ID: ' + str(run['job_id']) + '&#013;' + \
        'Job Serial: ' + run['job_serial'] + '&#013;'

    # Create link tags with # of success/skip/fail as the link text
    if run['run_status'] == 0:
        # Construct link tag
        success = run['tests_ok']
        skip = run['tests_ok_skip']
        fail =  run['tests_failed'] + run['tests_error'] + run['tests_bad_skip']
        link_location = run_dir + '/osg-test-' + date + '.log'
        link = Tag('a', href=link_location).append("%s %s %s" % (success, skip, fail))

        # Info for successful jobs
        mouseover_text = mouseover_text + 'Run Dir: ' + run['run_directory'] + '/output-' + run['job_serial'] + '&#013;' + \
            'Guest IP: ' + run['guest_address'] + '&#013;' + \
            'OSG Test Version: ' + run['osg_test_version'] + '&#013;' + \
            'Start Time: ' + str(run['start_time']) + '&#013;' + \
            'Run Time: ' + str(run['run_time'])
        
        if fail == 0:
            return Tag('td', class_='result pass', align='center', title=mouseover_text).append(link)
        else:
            mouseover_text = mouseover_text + '&#013;Failures:&#013;' 
            for msg in run['tests_messages']:
                mouseover_text = mouseover_text + msg + '&#013;' 
            return Tag('td', class_='result fail', align='center', title=mouseover_text).append(link)
    else:
        mouseover_text = mouseover_text + 'Run Summary: ' + run['run_summary']
        link_location = run_dir + '/run-job.log'
        link = Tag('a', class_='data', href=link_location).append('DIED')
        return Tag('td', class_='result die', align='center', title=mouseover_text).append(link)

def print_html_to_file(html, filename):
    f = open(filename, 'w')
    f.write(str(html))
    f.close()
    
    
if __name__ == "__main__":
    # setup html objects
    html_repo, table_repo = create_html_and_table()
    html_pkg, table_pkg = create_html_and_table()

    # Read test parameters
    f = open('test-parameters.yaml', 'r')
    yaml_data = f.read()
    f.close()
    test_params = yaml.load(yaml_data)
    test_params['platform'] = sort_platforms_by_dver(test_params['platform'])
    test_params['packages'] = concat_packages(test_params['packages'])

    # Map runs to their rows
    f = open('combined-analysis.yaml', 'r')
    yaml_data = f.read()
    f.close()
    runs = yaml.load(yaml_data)

    # Create and print repo organized html
    repo_organized_runs = make_data_grid(runs, test_params)
    populate_table_data(create_table_headers(table_repo),
                        repo_organized_runs)
    print_html_to_file(html_repo, repo_filename)
    
    # Create and print pkg organized html
    pkg_organized_runs = make_data_grid(runs, test_params, organization_scheme='packages')
    populate_table_data(create_table_headers(table_pkg, organization_scheme='packages'),
                        pkg_organized_runs,
                        organization_scheme='packages')
    print_html_to_file(html_pkg, pkg_filename)
